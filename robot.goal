init module {
	knowledge{
		% Predicate room(X) holds if X is a room.
		room(X):- rooms(L), member(X,L).
		
		% nextColorInSeq(Colour) returns Colour of the next block that should be found by the bot.
		nextColorInSeq(Colour) :- sequenceIndex(Number), sequence(Colours), nth0(Number,Colours, Colour).		
		
		% Returns the place in AllPlaces that is closest in travel time to CurrentPlace.
		closestPlace(AllPlaces,CurrentPlace,ClosestPlace) :-
			getClosestPlace(AllPlaces,ClosestPlace,[CurrentPlace]).

		% Gets all places neighbouring at least one place in the list provided as first argument.
		getNeighbours([],[]).
		getNeighbours([A|T],Neighbours) :-
			findall(N,neighbour(A,N),NList),
			getNeighbours(T,NewNeighbours),
			append(NewNeighbours,NList,Neighbours).
			
		% Find the closest place in the graph that intersects with the list of rooms provided.
		% Uses breadth-first search for easy shortest-path finding in the graph
		% AllPlaces is the list of all places from which the closest to the current place should be returned.
		% ClosestPlace is that closest place.
		% Acc is an accumulating list initialized at the current (starting) place.
		getClosestPlace(AllPlaces,ClosestPlace,Acc) :-
			getNeighbours(Acc,FoundList),
			flatten(FoundList,FlatList),
			append(Acc,FlatList,NewList),
			list_to_set(NewList,NewAcc),
			intersection(AllPlaces,NewAcc,NewFoundList),
			length(NewFoundList,Size),
			( Size > 0
			->nth0(0, NewFoundList, ClosestPlace)
			;
			(   length(NewAcc, NewLength), length(Acc, NewLength))
			->  false
			;   getClosestPlace(AllPlaces,ClosestPlace,NewAcc)).
	}
	
	beliefs{
		state(unknown).
	}
	
	program{
		% Inserts all places in beliefs on initialization
		forall bel(percept(place(R))) do insert(place(R)).
		
		% Inserts the agents own name in beliefs on initialization
		forall bel(percept(ownName(X))) do insert(ownName(X)).
		
		% Inserts all navpoints in beliefs on initialization
		forall bel(percept(navpoint(Nb, Room, X, Y, Neightbours))) do insert(navpoint(Nb, Room, X, Y, Neightbours)).
		
		% Inserts the sequence of blocks to be retrieved in beliefs on initialization
		forall bel(percept(sequence(Colours))) do insert(sequence(Colours)).
		
		% Inserts list of all valid rooms in beliefs on initialization
		if bel(findall(R, (place(R), R \== 'DropZone', navpoint(_,R,_,_,Neighbours), length(Neighbours,1)), Rooms)) then insert(rooms(Rooms)).
		
		% Adopts the list of rooms in goals on initialization
		forall bel(place(Place), room(Place)) do adopt(at(Place)).
		
		% Inserts the neighbouring graph of the entire map in beliefs on initialization
		forall bel(navpoint(_,Room,_,_,L),member(X,L)) do insert(neighbour(Room,X),neighbour(X,Room)).
		
		% Inserts the list of unvisited rooms in beliefs on initialization
		if bel(findall(R, room(R), L)) then insert(unvisited(L)).
	}
		
	actionspec{	
		% Actions are only executed if the precondition of that action holds.
		
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(Location) {
            pre { (state(arrived); state(collided)), place(Location) }
			post { true }
		}
		
		% The goToBlock action makes to agent move to a block in a room.
		% As long as the agent has not arrived at the block it is going to, it will be in "traveling" mode.
		goToBlock(Block) {
            pre { state(arrived), at(Room), color(Room, Block,_)  } %TODO: mss aanpassen met nextColorInSeq
			post { atBlock(Block), state(arrived) }
		}
		
		% The pickUp action makes the agent pick up the block it is currently located at.
		pickUp {
            pre { state(arrived), atBlock(BlockID), not(holding(_)), state(arrived) }
			post { holding(BlockID) }
		}
		
		% The putDown action makes the agent put down the block it is currently holding.
		putDown {
            pre { state(arrived), holding(BlockID) }
			post { not(holding(BlockID)) }
		}
		
	}
}

main module{
	program {
		#define closestRoomFromCurrentPlace(L, Room) bel(at(CR), closestPlace(L,CR,Room)).
		
		% #define nextBlockToPickup(Room, BlockID) bel(color(Room, BlockID, ColourID), nextColorInSeq(ColourID)), not(bel(new_target(_1, _2))).
		%#define nextBlockToPickup(Room, BlockID) 
		%	bel(nextColorInSeq(ColourID), findall(PossibleRoom, color(PossibleRoom, _, ColourID), PossibleRooms), color(NewRoom, BlockID, ColourID), not(bel(new_target(_1, _2)))), closestRoomFromCurrentPlace(PossibleRooms, NewRoom).
			
		forall bel(not(nextColorInSeq(_))), a-goal(at(Room)) do drop(at(Room)).
		
		if bel(nextColorInSeq(ColourID), findall(PossibleRoom, color(PossibleRoom, _, ColourID), PossibleRooms), color(NewRoom, BlockID, ColourID)), not(bel(new_target(_1, _2))), closestRoomFromCurrentPlace(PossibleRooms, NewRoom)  then insert(new_target(NewRoom, BlockID)) + adopt(holding(BlockID)) + adopt(atBlock(BlockID), state(arrived)) + adopt(at(NewRoom)).
		
		if a-goal(at(Room)), bel(new_target(Room,_)) then goTo(Room).
		
		if a-goal(atBlock(BlockID), state(arrived)), bel(new_target(_,BlockID)) then goToBlock(BlockID).
		
		if a-goal(holding(BlockID)), bel(atBlock(BlockID), new_target(_,BlockID)) then adopt(at('DropZone')).
		if a-goal(holding(BlockID)), bel(atBlock(BlockID), new_target(_,BlockID)) then pickUp.
		
		if a-goal(at('DropZone')), bel(holding(BlockID), new_target(_,BlockID)) then adopt(dropBlock(BlockID)).
		if a-goal(at('DropZone')), bel(holding(BlockID), new_target(_,BlockID)) then goTo('DropZone').
		
		if a-goal(dropBlock(BlockID)), bel(at('DropZone'), new_target(Room, BlockID)) then putDown.
		if a-goal(dropBlock(BlockID)), bel(at('DropZone'), new_target(Room, BlockID)), not(bel(holding(BlockID))) then delete(new_target(Room, BlockID)) + drop(dropBlock(BlockID)).
		
		% Chooses the goal room that is closest to the current one for optimal pathfinding.
		if a-goal(at(Room)), bel(unvisited(L)), closestRoomFromCurrentPlace(L, Room) then goTo(Room).
		
		% Assignment II.5: improve the two lines of code above such that the agent 
		%   checks the rooms in a more efficient way (not checking the same room 
		%   twice, for example).
		
		% Assignment II.6: insert code that makes the agent deliver a block when it 
		%   knows about a block that can be delivered. Make sure you use the goal base
		%	to set goals where the agent should go.	
		
		% (Optional) Assignment III.2: implement dealing with unexpected block removal.
		
		% (Optional) Assignment III.3: implement dealing with unexpected block delivery.		
	}
}

event module{
	program{
		%%%%% percepts sent on change %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
		if bel(not(at(_)), percept(at(Place))) then insert(at(Place)).
		if bel(at(OldPlace), percept(at(Place))) then insert(not(at(OldPlace)),at(Place)).
		
		if bel(percept(at(Place)), unvisited(L), select(Place, L, NewL), L\== NewL) then delete(unvisited(L)) + insert(unvisited(NewL)).
		

		if bel(not(state(_)), percept(state(State))) then insert(state(State)).		
		if bel(state(OldState), percept(state(State)) ) then insert(not(state(OldState)), state(State)).
		
		if bel(percept(occupied(Room))) then insert(occupied(Room)). 
		if bel(percept(not(occupied(Room)))) then insert(not(occupied(Room))). 
		
		% Color in a room
		
		%TODO: Verwijder alle kleuren van de kamer + mss nog controleren met atBlock
		% forall bel(color(Room,BlockID, ColourID), percept(at(Room))) do insert(not(color(Room,BlockID, ColourID))).
		forall bel(percept(at(Room)), color(Room, Block, Colour)) do delete(color(Room, Block, Colour)).
		forall bel(percept(color(BlockID, ColourID)), at(Room)) do insert(color(Room,BlockID, ColourID)).
		forall bel(percept(holding(BlockID)), percept(not(color(BlockID, ColourID))), color(Room, BlockID, ColourID)) do delete(color(Room,BlockID, ColourID)).
		
		if bel(percept(holding(BlockID))) then insert(holding(BlockID)).
		if bel(percept(not(holding(BlockID)))) then insert(not(holding(BlockID))).
		
		
		if bel(percept(sequenceIndex(ColourID)), sequenceIndex(OldColorID)) then insert(not(sequenceIndex(OldColorID)), sequenceIndex(ColourID)).
		if bel(percept(sequenceIndex(ColourID))) then insert(sequenceIndex(ColourID)). 
		
		
		% Atblock
		forall bel(percept(not(atBlock(BlockID)))) do insert(not(atBlock(BlockID))).
		forall bel(percept(atBlock(BlockID))) do insert(atBlock(BlockID)).
		
		%%%%%%%%%%%%%%%%%% sending messages and processing received messages %%%%%%%%%%%%%%%%%%%%
		% (Optional) Assignment III.5b: insert one or more rule(s) for messages sent by other agents.
		% The following rule is an example of how to process a message containing a block ID.
		
		forall bel(received(Sender, block(Id))) do insert(block(Id)) + delete(received(Sender, block(Id))).
		
		% (Optional) Assignment III.5a: insert send-actions to implement the communication
		%    of your choice (may be implemented here or in the event module)
	}
}
