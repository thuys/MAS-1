init module {
	knowledge{
		% Hardcoded list of all rooms in the maps we use for the BW4T environment.
		% Note that room names are strings (to avoid that names with capitals are treated as variables).
		
		% TODO: niet hardcoden (zet in program)
		rooms(['RoomA1','RoomA2','RoomA3','RoomB1','RoomB2','RoomB3','RoomC1','RoomC2','RoomC3']).

		% Predicate room(X) holds if X is a room.
		room(X):- rooms(L), member(X,L).
		
		% Assignment II.2: insert a definition of the predicate "nextColorInSeq(Color)".
		nextColorInSeq(Colour) :- sequenceIndex(Number), sequence(Colours), nth0(Number,Colours, Colour).
		
	}
	
	beliefs{
		state(unknown).
	}
	
	program{
		% Assignment II.1a: insert here rules for processing percepts sent only at the beginning of a session.
		forall bel(percept(place(R))) do insert(place(R)).
		
		forall bel(percept(ownName(X))) do insert(ownName(X)).
		
		forall bel(percept(navpoint(Nb, Room, X, Y, Neightbours))) do insert(navpoint(Nb, Room, X, Y, Neightbours)).
		
		forall bel(percept(sequence(Colours))) do insert(sequence(Colours)).
		
		forall bel(place(Place), room(Place)) do adopt(at(Place)).
	}
		
	actionspec{	
		% Actions are only executed if the precondition of that action holds.
		
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(Location) {
            pre { (state(arrived); state(collided)), place(Location) }
			post { true }
		}
		
		% Assignment II.3a: insert a specification for the goToBlock(Block) action.
		% TODO: post condities...
		goToBlock(Block) {
            pre { at(Room), color(Room, Block,_)  } %TODO: mss aanpassen met nextColorInSeq
			post { true }
		}
		
		% Assignment II.3b: insert a specification for the pickUp action.
		% TODO: post condities...
		pickUp {
            pre { atBlock(BlockID), not(holding(_)), state(arrived) }
			post { true }
		}
		
		% Assignment II.3c: insert a specification for the putDown action.
		% TODO: post condities...
		putDown {
            pre { holding(_), state(arrived), holding(BlockID) }
			post { true }
		}
		
	}
}

main module{
	program {
		% TODO: in verschillende module! 
		if bel(color(Room, BlockID, ColourID), (nextColorInSeq(ColourID))) then pickupBlock.
		
		% Initial code.
		if a-goal(at(Place)) then goTo(Place).
		
		% Assignment II.5: improve the two lines of code above such that the agent 
		%   checks the rooms in a more efficient way (not checking the same room 
		%   twice, for example).
		
		% Assignment II.6: insert code that makes the agent deliver a block when it 
		%   knows about a block that can be delivered. Make sure you use the goal base
		%	to set goals where the agent should go.	
		
		% (Optional) Assignment III.2: implement dealing with unexpected block removal.
		
		% (Optional) Assignment III.3: implement dealing with unexpected block delivery.		
	}
}

event module{
	program{
		%%%%% percepts sent on change %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
		if bel(not(at(_)), percept(at(Place))) then insert(at(Place)).
		if bel(at(OldPlace), percept(at(Place))) then insert(not(at(OldPlace)),at(Place)).

		if bel(not(state(_)), percept(state(State))) then insert(state(State)).		
		if bel(state(OldState), percept(state(State)) ) then insert(not(state(OldState)), state(State)).
		
		if bel(percept(occupied(Room))) then insert(occupied(Room)). 
		if bel(percept(not(occupied(Room)))) then insert(not(occupied(Room))). 
		
		% Color in a room
		
		%TODO: Verwijder alle kleuren van de kamer + mss nog controleren met atBlock
		% forall bel(color(Room,BlockID, ColourID), percept(at(Room))) do insert(not(color(Room,BlockID, ColourID))).
		
		forall bel(percept(color(BlockID, ColourID)), at(Room)) do insert(color(Room,BlockID, ColourID)).
		
		if bel(percept(holding(BlockID))) then insert(holding(BlockID)).
		if bel(percept(not(holding(BlockID)))) then insert(not(holding(BlockID))).
		
		if bel(percept(sequenceIndex(ColourID))) then insert(sequenceIndex(ColourID)).
		if bel(percept(not(sequenceIndex(ColourID)))) then insert(not(sequenceIndex(ColourID))).
		
		
		% Atblock
		if bel(not(atBlock(_)), percept(atBlock(Place))) then insert(atBlock(Place)).
		if bel(atBlock(OldPlace), percept(atBlock(Place))) then insert(not(atBlock(OldPlace)),atBlock(Place)).
		
		
		%%%%%%%%%%%%%%%%%% sending messages and processing received messages %%%%%%%%%%%%%%%%%%%%
		% (Optional) Assignment III.5b: insert one or more rule(s) for messages sent by other agents.
		% The following rule is an example of how to process a message containing a block ID.
		
		forall bel(received(Sender, block(Id))) do insert(block(Id)) + delete(received(Sender, block(Id))).
		
		% (Optional) Assignment III.5a: insert send-actions to implement the communication
		%    of your choice (may be implemented here or in the event module)
	}
}

module pickupBlock{
	
%	goals {
%		color(Room, _, ColourID), nextColorInSeq(ColourID), at(Room).
%		% color(Room, BlockID, ColourID), nextColorInSeq(ColourID), holding(BlockID).
%		
%		
%		
%	}

	program {
		if a-goal(at(Room) , nextColorInSeq(ColourID)), bel(nextColorInSeq(ColourID)) then goTo(Room).
		
		if a-goal(atBlock(BlockID)) then goToBlock(BlockID).
		
		if a-goal(holding(BlockID)) then pickUp.
		
		% Zoeken van de huidige block
		if bel(color(Room, BlockID, ColourID), nextColorInSeq(ColourID)) then adopt(at(Room), nextColorInSeq(ColourID)) + adopt(atBlock(BlockID)) + adopt(holding(BlockID)).
	}
%	program {
%		% Droppen in dropzone
%		if a-goal(color('DropZone', BlockID, ColourID)), bel(holding(BlockID), at('DropZone')) then putDown + drop(color('DropZone', BlockID, ColourID)).
%		
%		
%		% rijden in dropzone
%		if a-goal(color('DropZone', BlockID, ColourID)), bel(holding(BlockID), not(at('DropZone'))) then goTo('DropZone').
%		
%		% oppicken
%		if a-goal(color('DropZone', BlockID, ColourID)), bel(not(holding(BlockID)), atBlock(BlockID), color(Room, BlockID, ColourID)) then pickUp.
%		
%		% rijden naar block
%		if a-goal(color('DropZone', BlockID, ColourID)), bel(color(Room, BlockID, _), at(Room), not(atBlock(BlockID))) then goToBlock(BlockID).
%		
%		% rijden naar kamer
%		if a-goal(color('DropZone', BlockID, ColourID)), bel(color(Room, BlockID, _), not(at(Room))) then goTo(Room).
%		
%		% Goal toevoegen	
%		
%		if bel(color(Room, BlockID, ColourID), nextColorInSeq(ColourID), Room \= 'DropZone') then adopt(color('DropZone', BlockID, ColourID)).
		
%	}
}
