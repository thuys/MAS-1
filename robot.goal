init module {
	knowledge{
		% Hardcoded list of all rooms in the maps we use for the BW4T environment.
		% Note that room names are strings (to avoid that names with capitals are treated as variables).
		
		% TODO: niet hardcoden (zet in program)
		rooms(['RoomA1','RoomA2','RoomA3','RoomB1','RoomB2','RoomB3','RoomC1','RoomC2','RoomC3']).

		% Predicate room(X) holds if X is a room.
		room(X):- rooms(L), member(X,L).
		
		% Assignment II.2: insert a definition of the predicate "nextColorInSeq(Color)".
		nextColorInSeq(Colour) :- sequenceIndex(Number), sequence(Colours), nth0(Number,Colours, Colour).
		
	}
	
	beliefs{
		state(unknown).
	}
	
	program{
		% Assignment II.1a: insert here rules for processing percepts sent only at the beginning of a session.
		forall bel(percept(place(R))) do insert(place(R)).
		
		forall bel(percept(ownName(X))) do insert(ownName(X)).
		
		forall bel(percept(navpoint(Nb, Room, X, Y, Neightbours))) do insert(navpoint(Nb, Room, X, Y, Neightbours)).
		
		forall bel(percept(sequence(Colours))) do insert(sequence(Colours)).
		
	}
		
	actionspec{	
		% Actions are only executed if the precondition of that action holds.
		
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(Location) {
            pre { (state(arrived); state(collided)), place(Location) }
			post { true }
		}
		
		% Assignment II.3a: insert a specification for the goToBlock(Block) action.
		% TODO: post condities...
		goToBlock(Block) {
            pre { at(Room), color(Room, Block,_)  } %TODO: mss aanpassen met nextColorInSeq
			post { true }
		}
		
		% Assignment II.3b: insert a specification for the pickUp action.
		% TODO: post condities...
		pickup {
            pre { atBlock(BlockID), not(holding(_)), state(arrived) }
			post { true }
		}
		
		% Assignment II.3c: insert a specification for the putDown action.
		% TODO: post condities...
		putDown {
            pre { holding(_), state(arrived), holding(BlockID) }
			post { true }
		}
		
	}
}

main module{
	program {
		% Initial code.
		if bel(place(Place), room(Place)) then adopt(in(Place)).
		if a-goal(in(Place)) then goTo(Place).
		
		% Assignment II.5: improve the two lines of code above such that the agent 
		%   checks the rooms in a more efficient way (not checking the same room 
		%   twice, for example).
		
		% Assignment II.6: insert code that makes the agent deliver a block when it 
		%   knows about a block that can be delivered. Make sure you use the goal base
		%	to set goals where the agent should go.	
		
		% (Optional) Assignment III.2: implement dealing with unexpected block removal.
		
		% (Optional) Assignment III.3: implement dealing with unexpected block delivery.		
	}
}

event module{
	program{
		%%%%% percepts sent on change %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
		if bel(not(at(_)), percept(at(Place))) then insert(at(Place)).
		if bel(at(OldPlace), percept(at(Place))) then insert(not(at(OldPlace)),at(Place)).

		if bel(not(state(_)), percept(state(State))) then insert(state(State)).		
		if bel(state(OldState), percept(state(State)) ) then insert(not(state(OldState)), state(State)).
		
		if bel(percept(occupied(Room))) then insert(occupied(Room)). 
		if bel(percept(not(occupied(Room)))) then insert(not(occupied(Room))). 
		
		% Color in a room
		
		%TODO: Verwijder alle kleuren van de kamer + mss nog controleren met atBlock
		% forall bel(color(Room,BlockID, ColourID), percept(at(Room))) do insert(not(color(Room,BlockID, ColourID))).
		
		forall bel(percept(color(BlockID, ColourID)), at(Room)) do insert(color(Room,BlockID, ColourID)).
		
		if bel(percept(holding(BlockID))) then insert(holding(BlockID)).
		if bel(percept(not(holding(BlockID)))) then insert(not(holding(BlockID))).
		
		if bel(percept(sequenceIndex(ColourID))) then insert(sequenceIndex(ColourID)).
		if bel(percept(not(sequenceIndex(ColourID)))) then insert(not(sequenceIndex(ColourID))).
		
		% Atblock
		
		%%%%%%%%%%%%%%%%%% sending messages and processing received messages %%%%%%%%%%%%%%%%%%%%
		% (Optional) Assignment III.5b: insert one or more rule(s) for messages sent by other agents.
		% The following rule is an example of how to process a message containing a block ID.
		forall bel(received(Sender, block(Id))) do insert(block(Id)) + delete(received(Sender, block(Id))).
		
		% (Optional) Assignment III.5a: insert send-actions to implement the communication
		%    of your choice (may be implemented here or in the event module)
	}
}
